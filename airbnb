1 Collatz Conjecture
If a number is odd, the next transform is 3*n+1
If a number is even, the next transform is n/2
The number is finally transformed into 1.
The step is how many transforms needed for a number turned into 1.
Given an integer n, output the max steps of transform number in [1, n] into 1.

package collatz_conjecture;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class CollatzConjecture {
    /*
        Collatz Conjecture
        AirBnB Interview Question
        https://en.wikipedia.org/wiki/Collatz_conjecture
     */
    public class Solution {
        private int findSteps(int num) {
            if (num <= 1) return 1;
            if (num % 2 == 0) return 1 + findSteps(num / 2);
            return 1 + findSteps(3 * num + 1);
        }

        public int findLongestSteps(int num) {
            if (num < 1) return 0;

            int res = 0;
            for (int i = 1; i <= num; i++) {
                int t = findSteps(i);
                res = Math.max(res, t);
            }

            return res;
        }
    }

    /*
        Collatz Conjecture - Memorization
        AirBnB Interview Question
        https://en.wikipedia.org/wiki/Collatz_conjecture
     */
    public class Solution_2 {
        Map<Integer, Integer> map = new HashMap<>();

        private int findSteps(int num) {
            if (num <= 1) return 1;
            if (map.containsKey(num)) return map.get(num);
            if (num % 2 == 0) num = num / 2;
            else num = 3 * num + 1;
            if (map.containsKey(num)) return map.get(num) + 1;
            int t = findSteps(num);
            map.put(num, t);
            return t + 1;
        }

        public int findLongestSteps(int num) {
            if (num < 1) return 0;

            int res = 0;
            for (int i = 1; i <= num; i++) {
                int t = findSteps(i);
                map.put(i, t);
                res = Math.max(res, t);
            }

            return res;
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new CollatzConjecture().new Solution();
            assertEquals(1, sol.findLongestSteps(1));
            assertEquals(20, sol.findLongestSteps(10));
            assertEquals(112, sol.findLongestSteps(37));
            assertEquals(119, sol.findLongestSteps(101));
        }

        @Test
        public void test2() {
            Solution_2 sol = new CollatzConjecture().new Solution_2();
            assertEquals(1, sol.findLongestSteps(1));
            assertEquals(20, sol.findLongestSteps(10));
            assertEquals(112, sol.findLongestSteps(37));
            assertEquals(119, sol.findLongestSteps(101));
        }
    }
}

2 Implement Queue with Limited Size of Array
Implement a queue with a number of arrays, in which each array has fixed size.

package implement_queue_with_fixed_size_of_arrays;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class ImplementQueuewithFixedSizeofArrays {
    /*
        Implement Queue with Fixed Size of Arrays
        AirBnB Interview Question
     */
    public class QueueWithFixedArray {
        private int fixedSize;

        private int count;
        private int head;
        private int tail;
        private List<Object> headList;
        private List<Object> tailList;

        public QueueWithFixedArray(int fixedSize) {
            this.fixedSize = fixedSize;
            this.count = 0;
            this.head = 0;
            this.tail = 0;
            this.headList = new ArrayList<>();
            this.tailList = this.headList;
        }

        public void offer(int num) {
            if (tail == fixedSize - 1) {
                List<Object> newList = new ArrayList<>();
                newList.add(num);
                tailList.add(newList);
                tailList = (List<Object>) tailList.get(tail);
                tail = 0;
            } else {
                tailList.add(num);
            }
            count++;
            tail++;
        }

        public Integer poll() {
            if (count == 0) {
                return null;
            }

            int num = (int) headList.get(head);
            head++;
            count--;

            if (head == fixedSize - 1) {
                List<Object> newList = (List<Object>) headList.get(head);
                headList.clear();
                headList = newList;
                head = 0;
            }

            return num;
        }

        public int size() {
            return count;
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            QueueWithFixedArray queue = new ImplementQueuewithFixedSizeofArrays().new QueueWithFixedArray(5);
            queue.offer(1);
            queue.offer(2);
            int res = queue.poll();
            assertEquals(1, res);
            queue.offer(3);
            queue.offer(4);
            queue.offer(5);
            queue.offer(6);
            queue.offer(7);
            queue.offer(8);
            queue.offer(9);
            res = queue.poll();
            assertEquals(2, res);
            res = queue.poll();
            assertEquals(3, res);
        }
    }
}

3 List of List Iterator
Given an array of arrays, implement an iterator class to allow the client to traverse and remove elements in the array list.

This iterator should provide three public class member functions:

boolean hasNext() return true if there is another element in the set
int next() return the value of the next element in the array
void remove() remove the last element returned by the iterator. That is, remove the element that the previous next() returned. This method can be called only once per call to next(), otherwise an exception will be thrown.

package list_of_list_iterator;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class ListofListIterator {
    /*
        List of List Iterator
        AirBnB Interview Question
     */
    public class Solution implements Iterator<Integer> {
        private int row, col;
        private List<List<Integer>> vec2d;

        public Solution(List<List<Integer>> vec) {
            row = 0;
            col = 0;
            vec2d = vec;
        }

        @Override
        public Integer next() {
            int val = vec2d.get(row).get(col);
            col++;
            return val;
        }

        @Override
        public boolean hasNext() {
            if (vec2d == null || vec2d.isEmpty())
                return false;
            while (row < vec2d.size()) {
                if (col < vec2d.get(row).size()) {
                    return true;
                } else {
                    row++;
                    col = 0;
                }
            }
            return false;
        }

        @Override
        public void remove() {
            List<Integer> listToBeRemoved;
            int rowToBeRemoved = row;
            int colToBeRemoved = col;
            if (col == 0) {
                rowToBeRemoved--;
                colToBeRemoved = vec2d.get(rowToBeRemoved).size() - 1;
                listToBeRemoved = vec2d.get(rowToBeRemoved);
            } else {
                colToBeRemoved--;
                listToBeRemoved = vec2d.get(rowToBeRemoved);
            }
            listToBeRemoved.remove(colToBeRemoved);
            if (listToBeRemoved.isEmpty()) {
                vec2d.remove(listToBeRemoved);
                row--;
            }
            if (col > 0)
                col--;
        }
    }


    /*
        List of List Iterator
        AirBnB Interview Question
     */
    public class Solution_2 implements Iterator<Integer> {
        private Iterator<List<Integer>> rowIter;
        private Iterator<Integer> colIter;

        public Solution_2(List<List<Integer>> vec2d) {
            rowIter = vec2d.iterator();
            colIter = Collections.emptyIterator();
        }

        @Override
        public Integer next() {
            return colIter.next();
        }

        @Override
        public boolean hasNext() {
            while ((colIter == null || !colIter.hasNext()) && rowIter.hasNext())
                colIter = rowIter.next().iterator();
            return colIter != null && colIter.hasNext();
        }

        @Override
        public void remove() {
            while (colIter == null && rowIter.hasNext())
                colIter = rowIter.next().iterator();
            if (colIter != null)
                colIter.remove();
        }
    }


    public static class UnitTest {
        @Test
        public void test1() {
            List<List<Integer>> test = new ArrayList<>();
            test.add(new ArrayList<Integer>() {{
                add(1);
                add(2);
            }});
            test.add(new ArrayList<Integer>() {{
                add(3);
            }});
            test.add(new ArrayList<Integer>() {{
                add(4);
                add(5);
                add(6);
            }});
            Solution sol = new ListofListIterator().new Solution(test);
            assertTrue(sol.hasNext());
            assertEquals(1, (int) sol.next());
            sol.remove();
            List<Integer> res = new ArrayList<>();
            while (sol.hasNext()) {
                res.add(sol.next());
            }
            assertEquals(5, res.size());
            assertEquals(2, (int) res.get(0));
            assertEquals(4, (int) res.get(2));
            assertEquals(6, (int) res.get(4));

            test = new ArrayList<>();
            test.add(new ArrayList<Integer>() {{
                add(1);
                add(2);
            }});
            test.add(new ArrayList<Integer>() {{
                add(3);
            }});
            sol = new ListofListIterator().new Solution(test);
            assertTrue(sol.hasNext());
            assertEquals(1, (int) sol.next());
            assertTrue(sol.hasNext());
            assertEquals(2, (int) sol.next());
            sol.remove();
            assertTrue(sol.hasNext());
            assertEquals(3, (int) sol.next());
        }

        @Test
        public void test2() {
            List<List<Integer>> test = new ArrayList<>();
            test.add(new ArrayList<Integer>() {{
                add(1);
                add(2);
            }});
            test.add(new ArrayList<Integer>() {{
                add(3);
            }});
            test.add(new ArrayList<Integer>() {{
                add(4);
                add(5);
                add(6);
            }});
            Solution_2 sol = new ListofListIterator().new Solution_2(test);
            assertTrue(sol.hasNext());
            assertEquals(1, (int) sol.next());
            sol.remove();
            List<Integer> res = new ArrayList<>();
            while (sol.hasNext()) {
                res.add(sol.next());
            }
            assertEquals(5, res.size());
            assertEquals(2, (int) res.get(0));
            assertEquals(4, (int) res.get(2));
            assertEquals(6, (int) res.get(4));

            test = new ArrayList<>();
            test.add(new ArrayList<Integer>() {{
                add(1);
                add(2);
            }});
            test.add(new ArrayList<Integer>() {{
                add(3);
            }});
            sol = new ListofListIterator().new Solution_2(test);
            assertTrue(sol.hasNext());
            assertEquals(1, (int) sol.next());
            assertTrue(sol.hasNext());
            assertEquals(2, (int) sol.next());
            sol.remove();
            assertTrue(sol.hasNext());
            assertEquals(3, (int) sol.next());
        }

    }
}

4 Display Page (Pagination)
Given an array of CSV strings representing search results, output results sorted by a score initially. A given host may have several listings that show up in these results. Suppose we want to show 12 results per page, but we don’t want the same host to dominate the results.

Write a function that will reorder the list so that a host shows up at most once on a page if possible, but otherwise preserves the ordering. Your program should return the new array and print out the results in blocks representing the pages.

Given an array of csv strings, output results separated by a blank line.

package display_page;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class DisplayPage {
    /*
        Display Page - LinkedList + HashSet
        AirBnB Interview Question
     */
    public class Solution {
        public List<String> displayPages(List<String> input, int pageSize) {
            List<String> res = new ArrayList<>();
            if (input == null || input.size() == 0) {
                return res;
            }

            List<String> visited = new ArrayList<>();
            Iterator<String> iter = input.iterator();
            boolean reachEnd = false;
            while (iter.hasNext()) {
                String curr = iter.next();
                String hostId = curr.split(",")[0];
                if (!visited.contains(hostId) || reachEnd) {
                    res.add(curr);
                    visited.add(hostId);
                    iter.remove();
                }

                if (visited.size() == pageSize) {
                    visited.clear();
                    reachEnd = false;
                    if (!input.isEmpty()) {
                        res.add(" ");
                    }
                    iter = input.iterator();
                }

                if (!iter.hasNext()) {
                    iter = input.iterator();
                    reachEnd = true;
                }
            }

            return res;
        }
    }

    /*
        Display Page - Fill each page
        AirBnB Interview Question
     */
    public class Solution_2 {
        public List<String> displayPages(List<String> input, int pageSize) {
            List<String> res = new ArrayList<>();
            Iterator<String> iter = input.iterator();
            Set<String> set = new HashSet<>();
            boolean reachEnd = false;
            int counter = 0;
            while (iter.hasNext()) {
                String cur = iter.next();
                String id = (cur.split(","))[0];
                if (!set.contains(id) || reachEnd) {
                    res.add(cur);
                    set.add(id);
                    iter.remove();
                    counter++;
                }

                if (counter == pageSize) {
                    if (!input.isEmpty())
                        res.add(" ");
                    set.clear();
                    counter = 0;
                    reachEnd = false;
                    iter = input.iterator();
                }

                if (!iter.hasNext()) {
                    reachEnd = true;
                    iter = input.iterator();
                }
            }

            return res;
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new DisplayPage().new Solution();
            String[] strs = new String[]{
                    "1,28,300.1,SanFrancisco",
                    "4,5,209.1,SanFrancisco",
                    "20,7,208.1,SanFrancisco",
                    "23,8,207.1,SanFrancisco",
                    "16,10,206.1,Oakland",
                    "1,16,205.1,SanFrancisco",
                    "6,29,204.1,SanFrancisco",
                    "7,20,203.1,SanFrancisco",
                    "8,21,202.1,SanFrancisco",
                    "2,18,201.1,SanFrancisco",
                    "2,30,200.1,SanFrancisco",
                    "15,27,109.1,Oakland",
                    "10,13,108.1,Oakland",
                    "11,26,107.1,Oakland",
                    "12,9,106.1,Oakland",
                    "13,1,105.1,Oakland",
                    "22,17,104.1,Oakland",
                    "1,2,103.1,Oakland",
                    "28,24,102.1,Oakland",
                    "18,14,11.1,SanJose",
                    "6,25,10.1,Oakland",
                    "19,15,9.1,SanJose",
                    "3,19,8.1,SanJose",
                    "3,11,7.1,Oakland",
                    "27,12,6.1,Oakland",
                    "1,3,5.1,Oakland",
                    "25,4,4.1,SanJose",
                    "5,6,3.1,SanJose",
                    "29,22,2.1,SanJose",
                    "30,23,1.1,SanJose"
            };
            List<String> input = new ArrayList<>(Arrays.asList(strs));
            List<String> result = sol.displayPages(input, 12);
            assertEquals(32, result.size());
            assertEquals("1,28,300.1,SanFrancisco", result.get(0));
            assertEquals("11,26,107.1,Oakland", result.get(11));
            assertEquals(" ", result.get(12));
            assertEquals("1,16,205.1,SanFrancisco", result.get(13));
            assertEquals("2,30,200.1,SanFrancisco", result.get(14));
            assertEquals("25,4,4.1,SanJose", result.get(24));
            assertEquals(" ", result.get(25));
            assertEquals("1,2,103.1,Oakland", result.get(26));
            assertEquals("3,11,7.1,Oakland", result.get(27));
            assertEquals("30,23,1.1,SanJose", result.get(30));
            assertEquals("1,3,5.1,Oakland", result.get(31));
        }

        @Test
        public void test2() {
            Solution_2 sol = new DisplayPage().new Solution_2();
            String[] strs = new String[]{
                    "1,28,310.6,SF",
                    "4,5,204.1,SF",
                    "20,7,203.2,Oakland",
                    "6,8,202.2,SF",
                    "6,10,199.1,SF",
                    "1,16,190.4,SF",
                    "6,29,185.2,SF",
                    "7,20,180.1,SF",
                    "6,21,162.1,SF",
                    "2,18,161.2,SF",
                    "2,30,149.1,SF",
                    "3,76,146.2,SF",
                    "2,14,141.1,San Jose"

            };
            List<String> input = new ArrayList<>(Arrays.asList(strs));
            List<String> result = sol.displayPages(input, 5);
            assertEquals(15, result.size());
            assertEquals("1,28,310.6,SF", result.get(0));
            assertEquals("7,20,180.1,SF", result.get(4));
            assertEquals(" ", result.get(5));
            assertEquals("6,10,199.1,SF", result.get(6));
            assertEquals("6,29,185.2,SF", result.get(10));
            assertEquals(" ", result.get(11));
            assertEquals("6,21,162.1,SF", result.get(12));
            assertEquals("2,14,141.1,San Jose", result.get(14));
        }
    }
}


5 Travel Buddy
I have a wish list of cities that I want to visit to, my friends also have city wish lists that they want to visit to. If one of my friends share more than 50% (over his city count in his wish list), he is my buddy.

Given a list of city wish list, output buddy list sorting by similarity.

package travel_buddy;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class TravelBuddy {
    /*
        Travel Buddy
        AirBnB Interview Question
     */
    public class Solution {
        private List<Buddy> buddies;
        private Set<String> myWishList;

        public Solution(Set<String> myWishList, Map<String, Set<String>> friendsWishList) {
            this.buddies = new ArrayList<>();
            this.myWishList = myWishList;
            for (String name : friendsWishList.keySet()) {
                Set<String> wishList = friendsWishList.get(name);
                Set<String> intersection = new HashSet<>(wishList);
                intersection.retainAll(myWishList);
                int similarity = intersection.size();
                if (similarity >= wishList.size() / 2) {
                    buddies.add(new Buddy(name, similarity, wishList));
                }
            }
        }

        public List<Buddy> getSortedBuddies() {
            Collections.sort(buddies);
            List<Buddy> res = new ArrayList<>(buddies);
            return res;
        }

        public List<String> recommendCities(int k) {
            List<String> res = new ArrayList<>();
            List<Buddy> buddies = getSortedBuddies();

            int i = 0;
            while (k > 0 && i < buddies.size()) {
                Set<String> diff = new HashSet<>(buddies.get(i).wishList);
                diff.removeAll(myWishList);
                if (diff.size() <= k) {
                    res.addAll(diff);
                    k -= diff.size();
                    i++;
                } else {
                    Iterator<String> it = diff.iterator();
                    while (k > 0) {
                        res.add(it.next());
                        k--;
                    }
                }
            }

            return res;
        }

        class Buddy implements Comparable<Buddy> {
            String name;
            int similarity;
            Set<String> wishList;

            Buddy(String name, int similarity, Set<String> wishList) {
                this.name = name;
                this.similarity = similarity;
                this.wishList = wishList;
            }

            @Override
            public int compareTo(Buddy that) {
                return that.similarity - this.similarity;
            }
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Set<String> myWishList = new HashSet<>(Arrays.asList(new String[]{"a", "b", "c", "d"}));
            Set<String> wishList1 = new HashSet<>(Arrays.asList(new String[]{"a", "b", "e", "f"}));
            Set<String> wishList2 = new HashSet<>(Arrays.asList(new String[]{"a", "c", "d", "g"}));
            Set<String> wishList3 = new HashSet<>(Arrays.asList(new String[]{"c", "f", "e", "g"}));
            Map<String, Set<String>> friendWishLists = new HashMap<>();
            friendWishLists.put("Buddy1", wishList1);
            friendWishLists.put("Buddy2", wishList2);
            friendWishLists.put("Buddy3", wishList3);
            Solution sol = new TravelBuddy().new Solution(myWishList, friendWishLists);
            List<String> res = sol.recommendCities(10);
            assertEquals(3, res.size());
            assertEquals("g", res.get(0));
            assertEquals("e", res.get(1));
            assertEquals("f", res.get(2));
        }
    }
}


6 File System
Write a file system class, which has two functions: create, and get

create("/a",1)
get("/a") //get 1
create("/a/b",2)
get("/a/b") //get 2
create("/c/d",1) //Error, because "/c" is not existed
get("/c") //Error, because "/c" is not existed

package file_system;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class FileSystem {
    /*
        File System
        AirBnB Interview Question
     */
    public class Solution {
        Map<String, Integer> pathMap;
        Map<String, Runnable> callbackMap;

        public Solution() {
            this.pathMap = new HashMap<>();
            this.callbackMap = new HashMap<>();
            this.pathMap.put("", 0);
        }

        public boolean create(String path, int value) {
            if (pathMap.containsKey(path)) {
                return false;
            }

            int lastSlashIndex = path.lastIndexOf("/");
            if (!pathMap.containsKey(path.substring(0, lastSlashIndex))) {
                return false;
            }

            pathMap.put(path, value);
            return true;
        }

        public boolean set(String path, int value) {
            if (!pathMap.containsKey(path)) {
                return false;
            }

            pathMap.put(path, value);

            // Trigger callbacks
            String curPath = path;
//            while (curPath.length() > 0) {
//                if (callbackMap.containsKey(curPath)) {
//                    callbackMap.get(curPath).run();
//                }
//                int lastSlashIndex = path.lastIndexOf("/");
//                curPath = curPath.substring(0, lastSlashIndex);
//            }

            return true;
        }

        public Integer get(String path) {
            return pathMap.get(path);
        }

        public boolean watch(String path, Runnable callback) {
            if (!pathMap.containsKey(path)) {
                return false;
            }

            callbackMap.put(path, callback);
            return true;
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new FileSystem().new Solution();
            assertTrue(sol.create("/a",1));
            assertEquals(1, (int)sol.get("/a"));
            assertTrue(sol.create("/a/b",2));
            assertEquals(2, (int)sol.get("/a/b"));
            assertTrue(sol.set("/a/b",3));
            assertEquals(3, (int)sol.get("/a/b"));
            assertFalse(sol.create("/c/d",4));
            assertFalse(sol.set("/c/d",4));

            sol = new FileSystem().new Solution();
            assertTrue(sol.create("/NA",1));
            assertTrue(sol.create("/EU",2));
            assertEquals(1, (int)sol.get("/NA"));
            assertTrue(sol.create("/NA/CA",101));
            assertEquals(101, (int)sol.get("/NA/CA"));
            assertTrue(sol.set("/NA/CA",102));
            assertEquals(102, (int)sol.get("/NA/CA"));
            assertTrue(sol.create("/NA/US",101));
            assertEquals(101, (int)sol.get("/NA/US"));
            assertFalse(sol.create("/NA/CA",101));
            assertFalse(sol.create("/SA/MX",103));
            assertFalse(sol.set("SA/MX",103));
        }
    }
}


7 Palindrome Pairs
Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.

package palindrome_pairs;

import java.util.*;
import org.junit.*;
import static org.junit.Assert.*;

public class PalindromePairs {
    /*
        Palindrome Pairs - HashMap
        AirBnB Interview Question
     */
    public class Solution {
        private boolean isPalindrome(String s) {
            for (int i = 0; i < s.length() / 2; ++i)
                if (s.charAt(i) != s.charAt(s.length() - 1 - i))
                    return false;
            return true;
        }

        public List<List<Integer>> palindromePairs(String[] words) {
            List<List<Integer>> res = new ArrayList<>();
            if (words == null) return res;
            HashMap<String, Integer> map = new HashMap<>();
            for (int i = 0; i < words.length; i++) map.put(words[i], i);
            for (int i = 0; i < words.length; i++) {
                int left = 0, right = 0;
                while (left <= right) {
                    String s = words[i].substring(left, right);
                    Integer j = map.get(new StringBuilder(s).reverse().toString());
                    if (j != null && i != j && isPalindrome(words[i].substring(left == 0 ? right : 0, left == 0 ? words[i].length() : left)))
                        res.add(Arrays.asList(left == 0 ? new Integer[]{i, j} : new Integer[]{j, i}));
                    if (right < words[i].length()) right++;
                    else left++;
                }
            }
            return res;
        }
    }

    /*
        Palindrome Pairs - Trie
        AirBnB Interview Question
     */
    public class Solution_2 {
        class TrieNode {
            TrieNode[] next;
            int index;
            List<Integer> list;

            TrieNode() {
                next = new TrieNode[26];
                index = -1;
                list = new ArrayList<>();
            }
        }

        private void addWord(TrieNode root, String word, int index) {
            for (int i = word.length() - 1; i >= 0; i--) {
                if (root.next[word.charAt(i) - 'a'] == null) {
                    root.next[word.charAt(i) - 'a'] = new TrieNode();
                }

                if (isPalindrome(word, 0, i)) {
                    root.list.add(index);
                }

                root = root.next[word.charAt(i) - 'a'];
            }

            root.list.add(index);
            root.index = index;
        }

        private boolean isPalindrome(String word, int i, int j) {
            while (i < j) {
                if (word.charAt(i++) != word.charAt(j--)) return false;
            }

            return true;
        }

        private void search(String[] words, int i, TrieNode root, List<List<Integer>> list) {
            for (int j = 0; j < words[i].length(); j++) {
                if (root.index >= 0 && root.index != i && isPalindrome(words[i], j, words[i].length() - 1)) {
                    list.add(Arrays.asList(i, root.index));
                }

                root = root.next[words[i].charAt(j) - 'a'];
                if (root == null) return;
            }

            for (int j : root.list) {
                if (i == j) continue;
                list.add(Arrays.asList(i, j));
            }
        }

        public List<List<Integer>> palindromePairs(String[] words) {
            List<List<Integer>> res = new ArrayList<>();

            TrieNode root = new TrieNode();
            for (int i = 0; i < words.length; i++) {
                addWord(root, words[i], i);
            }

            for (int i = 0; i < words.length; i++) {
                search(words, i, root, res);
            }

            return res;
        }
    }
    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new PalindromePairs().new Solution();
            String[] test = new String[]{"bat", "tab", "cat"};
            List<List<Integer>> rslt = sol.palindromePairs(test);
            assertEquals(2, rslt.size());

            test = new String[]{"abcd", "dcba", "lls", "s", "sssll"};
            rslt = sol.palindromePairs(test);
            assertEquals(4, rslt.size());

            test = new String[]{"a", ""};
            rslt = sol.palindromePairs(test);
            assertEquals(2, rslt.size());
        }

        @Test
        public void test2() {
            Solution_2 sol = new PalindromePairs().new Solution_2();
            String[] test = new String[]{"bat", "tab", "cat"};
            List<List<Integer>> rslt = sol.palindromePairs(test);
            assertEquals(2, rslt.size());

            test = new String[]{"abcd", "dcba", "lls", "s", "sssll"};
            rslt = sol.palindromePairs(test);
            assertEquals(4, rslt.size());

            test = new String[]{"a", ""};
            rslt = sol.palindromePairs(test);
            assertEquals(2, rslt.size());
        }
    }
}

8 Find Median in Large Integer File of Integers
Find the median from a large file of integers. You can not access the numbers by index, can only access it sequentially. And the numbers cannot fit in memory.

package find_median_in_large_file_of_integers;

import org.junit.*;

import static org.junit.Assert.*;

public class FindMedianinLargeIntegerFileofIntegers {
    /*
        Find Median in Large Integer File of Integers
        AirBnB Interview Question
     */
    public class Solution {
        private long search(int[] nums, int k, long left, long right) {
            if (left >= right) {
                return left;
            }

            long res = left;
            long guess = left + (right - left) / 2;
            int count = 0;
            for (int num : nums) {
                if (num <= guess) {
                    count++;
                    res = Math.max(res, num);
                }
            }

            if (count == k) {
                return res;
            } else if (count < k) {
                return search(nums, k, Math.max(res + 1, guess), right);
            } else {
                return search(nums, k, left, res);
            }
        }

        public double findMedian(int[] nums) {
            int len = 0;
            for (int num : nums) {
                len++;
            }

            if (len % 2 == 1) {
                return (double) search(nums, len / 2 + 1, Integer.MIN_VALUE, Integer.MAX_VALUE);
            } else {
                return (double) (search(nums, len / 2, Integer.MIN_VALUE, Integer.MAX_VALUE) +
                        search(nums, len / 2 + 1, Integer.MIN_VALUE, Integer.MAX_VALUE)) / 2;
            }
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new FindMedianinLargeIntegerFileofIntegers().new Solution();
            assertEquals(3.0, sol.findMedian(new int[]{3, -2, 7}), 1E-03);
            assertEquals(5.0, sol.findMedian(new int[]{-100, 99, 3, 0, 5, 7, 11, 66, -33}), 1E-03);
            assertEquals(4.5, sol.findMedian(new int[]{4, -100, 99, 3, 0, 5, 7, 11, 66, -33}), 1E-03);
        }
    }
}

9 IP Range to CIDR
Given an IPv4 IP address p and an integer n, return a list of CIDR strings that most succinctly represents the range of IP addresses from p to (p + n).

package ip_range_to_cidr;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class IPRangetoCIDR {
    /*
        IP range to CIDR
        https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing
        http://www.ipaddressguide.com/cidr
        https://stackoverflow.com/questions/33443914/how-to-convert-ip-address-range-to-cidr-in-java
        AirBnB Interview Question
     */
    public class Solution {
        private long ipToLong(String strIP) {
            long[] ip = new long[4];
            String[] ipSec = strIP.split("\\.");
            for (int k = 0; k < 4; k++) {
                ip[k] = Long.valueOf(ipSec[k]);
            }

            return (ip[0] << 24) + (ip[1] << 16) + (ip[2] << 8) + ip[3];
        }

        private String longToIP(long longIP) {
            StringBuffer sb = new StringBuffer("");
            sb.append(String.valueOf(longIP >>> 24));
            sb.append(".");
            sb.append(String.valueOf((longIP & 0x00FFFFFF) >>> 16));
            sb.append(".");
            sb.append(String.valueOf((longIP & 0x0000FFFF) >>> 8));
            sb.append(".");
            sb.append(String.valueOf(longIP & 0x000000FF));

            return sb.toString();
        }

        public List<String> ipRange2Cidr(String startIp, int range) {
            // check parameters
            String a = "";
            long start = ipToLong(startIp);
            long end = start + range - 1;
            List<String> res = new ArrayList<>();
            while (start <= end) {
                // identify the location of first 1's from lower bit to higher bit of start IP
                // e.g. 00000001.00000001.00000001.01101100, return 4 (100)
                long locOfFirstOne = start & (-start);
                int curMask = 32 - (int) (Math.log(locOfFirstOne) / Math.log(2));

                // calculate how many IP addresses between the start and end
                // e.g. between 1.1.1.111 and 1.1.1.120, there are 10 IP address
                // 3 bits to represent 8 IPs, from 1.1.1.112 to 1.1.1.119 (119 - 112 + 1 = 8)
                double currRange = Math.log(end - start + 1) / Math.log(2);
                int currRangeMask = 32 - (int) Math.floor(currRange);

                // why max?
                // if the currRangeMask is larger than curMask
                // which means the numbers of IPs from start to end is smaller than mask range
                // so we can't use as many as bits we want to mask the start IP to avoid exceed the end IP
                // Otherwise, if currRangeMask is smaller than curMask, which means number of IPs is larger than mask range
                // in this case we can use curMask to mask as many as IPs from start we want.
                curMask = Math.max(currRangeMask, curMask);

                // Add to results
                String ip = longToIP(start);
                res.add(ip + "/" + curMask);
                // We have already included 2^(32 - curMask) numbers of IP into result
                // So the next roundUp start must insert that number
                start += Math.pow(2, (32 - curMask));
            }
            return res;
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new IPRangetoCIDR().new Solution();
            List<String> res = sol.ipRange2Cidr("255.0.0.7", 10);
            assertEquals(3, res.size());
            assertEquals("255.0.0.7/32", res.get(0));
            assertEquals("255.0.0.8/29", res.get(1));
            assertEquals("255.0.0.16/32", res.get(2));

            res = sol.ipRange2Cidr("1.1.1.0", 4);
            assertEquals(1, res.size());
            assertEquals("1.1.1.0/30", res.get(0));

            res = sol.ipRange2Cidr("1.1.1.1", 4);
            assertEquals(3, res.size());
            assertEquals("1.1.1.1/32", res.get(0));
            assertEquals("1.1.1.2/31", res.get(1));
            assertEquals("1.1.1.4/32", res.get(2));
        }
    }
}


10 CSV Parser
Write a method to parse input string in CSV format.

package csv_parser;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class CSVParser {
    /*
        CSV Parser
        AirBnB Interview Question
        http://creativyst.com/Doc/Articles/CSV/CSV01.htm#EmbedBRs
     */
    public class Solution {
        public String parseCSV(String str) {
            List<String> res = new ArrayList<>();
            boolean inQuote = false;
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < str.length(); i++) {
                if (inQuote) {
                    if (str.charAt(i) == '\"') {
                        if (i < str.length() - 1 && str.charAt(i + 1) == '\"') {
                            sb.append("\"");
                            i++;
                        } else {
                            inQuote = false;
                        }
                    } else {
                        sb.append(str.charAt(i));
                    }
                } else {
                    if (str.charAt(i) == '\"') {
                        inQuote = true;
                    } else if (str.charAt(i) == ',') {
                        res.add(sb.toString());
                        sb.setLength(0);
                    } else {
                        sb.append(str.charAt(i));
                    }
                }
            }

            if (sb.length() > 0) {
                res.add(sb.toString());
            }
            return String.join("|", res);
        }
    }

    /*
        CSV Parser
        AirBnB Interview Question
        http://creativyst.com/Doc/Articles/CSV/CSV01.htm#EmbedBRs
     */
    public class Solution_2 {
        public String parseCSV(String str) {
            if (str == null || str.isEmpty()) return null;
            List<String> res = new ArrayList<>();
            StringBuilder curr = new StringBuilder();
            boolean inQuote = false;
            for (int i = 0; i < str.length(); i++) {
                char c = str.charAt(i);
                if (inQuote) {
                    if (c == '\"') {
                        if (i < str.length() - 1 && str.charAt(i + 1) == '\"') {
                            curr.append("\"");
                            i++;
                        } else {
                            inQuote = false;
                        }
                    } else {
                        curr.append(c);
                    }
                } else {
                    if (c == '\"') {
                        inQuote = true;
                    } else if (c == ',') {
                        res.add(curr.toString());
                        curr.setLength(0);
                    } else {
                        curr.append(c);
                    }
                }
            }

            if (curr.length() > 0)
                res.add(curr.toString());

            return String.join("|", res);
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new CSVParser().new Solution();
            String test = "John,Smith,john.smith@gmail.com,Los Angeles,1";
            String expected = "John|Smith|john.smith@gmail.com|Los Angeles|1";
            assertEquals(expected, sol.parseCSV(test));

            test = "Jane,Roberts,janer@msn.com,\"San Francisco, CA\",0";
            expected = "Jane|Roberts|janer@msn.com|San Francisco, CA|0";
            assertEquals(expected, sol.parseCSV(test));

            test = "\"Alexandra \"\"Alex\"\"\",Menendez,alex.menendez@gmail.com,Miami,1";
            expected = "Alexandra \"Alex\"|Menendez|alex.menendez@gmail.com|Miami|1";
            assertEquals(expected, sol.parseCSV(test));

            test = "\"\"\"Alexandra Alex\"\"\"";
            expected = "\"Alexandra Alex\"";
            assertEquals(expected, sol.parseCSV(test));
        }

        @Test
        public void test2() {
            Solution_2 sol = new CSVParser().new Solution_2();
            String test = "John,Smith,john.smith@gmail.com,Los Angeles,1";
            String expected = "John|Smith|john.smith@gmail.com|Los Angeles|1";
            assertEquals(expected, sol.parseCSV(test));

            test = "Jane,Roberts,janer@msn.com,\"San Francisco, CA\",0";
            expected = "Jane|Roberts|janer@msn.com|San Francisco, CA|0";
            assertEquals(expected, sol.parseCSV(test));

            test = "\"Alexandra \"\"Alex\"\"\",Menendez,alex.menendez@gmail.com,Miami,1";
            expected = "Alexandra \"Alex\"|Menendez|alex.menendez@gmail.com|Miami|1";
            assertEquals(expected, sol.parseCSV(test));

            test = "\"\"\"Alexandra Alex\"\"\"";
            expected = "\"Alexandra Alex\"";
            assertEquals(expected, sol.parseCSV(test));
        }
    }
}


11 Text Justification
Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.



12 Regular Expression
Implement a simple regex parser which, given a string and a pattern, returns a boolean indicating whether the input matches the pattern.

By simple, we mean that the regex can only contain special character:

* (star) The star means what you'd expect, that there will be zero or more of previous character in that place in the pattern.
. (dot) The dot means any character for that position.
+ (plus). The plus means one or more of previous character in that place in the pattern.

package regular_expression;

import org.junit.*;

import static org.junit.Assert.*;

public class RegularExpression {
    /*
        Regular Expression
        AirBnB Interview Question
     */
    public class Solution {
        public boolean regMatch(String source, String pattern) {
            if (pattern.length() == 0) return source.length() == 0;
            if (pattern.length() == 1) {
                if (source.length() > 1 || source.length() == 0) return false;
                return source.charAt(0) == pattern.charAt(0);
            }

            if (source.length() != 0 && (pattern.charAt(0) == '.' || pattern.charAt(0) == source.charAt(0))) {
                if (pattern.charAt(1) == '*') {
                    return regMatch(source.substring(1), pattern) || regMatch(source, pattern.substring(2));
                } else if (pattern.charAt(1) == '+') {
                    return regMatch(source.substring(1), pattern.substring(2)) || regMatch(source.substring(1), pattern.substring(2));
                } else {
                    return regMatch(source.substring(1), pattern.substring(1));
                }
            }
            return pattern.charAt(1) == '*' && regMatch(source, pattern.substring(2));
        }
    }

    /*
        Regular Expression - Dynamic Programming
        AirBnB Interview Question
     */
    public class Solution_2 {
        public boolean regMatch(String s, String p) {
            if (s == null || p == null) return false;
            boolean[][] dp = new boolean[p.length() + 1][s.length() + 1];
            dp[0][0] = true;
            for (int i = 1; i <= p.length(); i++) {
                if (p.charAt(i - 1) == '*' && dp[i - 2][0]) dp[i][0] = true;
            }

            for (int i = 1; i <= p.length(); i++) {
                for (int j = 1; j <= s.length(); j++) {
                    if (p.charAt(i - 1) == '.' || p.charAt(i - 1) == s.charAt(j - 1)) {
                        dp[i][j] = dp[i - 1][j - 1];
                    } else if (p.charAt(i - 1) == '*' || p.charAt(i - 1) == '+') {
                        if (p.charAt(i - 2) == '.' || p.charAt(i - 2) == s.charAt(j - 1)) {
                            if (p.charAt(i - 1) == '*') {
                                dp[i][j] = dp[i - 2][j] || dp[i - 2][j - 1] || dp[i][j - 1];
                            } else {
                                dp[i][j] = dp[i - 2][j - 1] || dp[i][j - 1];
                            }
                        } else {
                            dp[i][j] = p.charAt(i - 1) == '*' && dp[i - 2][j];
                        }
                    }
                }
            }
            return dp[p.length()][s.length()];
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new RegularExpression().new Solution();
            assertTrue(sol.regMatch("saaaa", "s+a*"));
            assertFalse(sol.regMatch("saaaa", "s+b*"));
            assertFalse(sol.regMatch("saaaab", "s+a*"));
            assertFalse(sol.regMatch("saaaab", "s+b*"));
        }

        @Test
        public void test2() {
            Solution_2 sol = new RegularExpression().new Solution_2();
            assertTrue(sol.regMatch("saaaa", "s+a*"));
            assertFalse(sol.regMatch("saaaa", "s+b*"));
            assertFalse(sol.regMatch("saaaab", "s+a*"));
            assertFalse(sol.regMatch("saaaab", "s+b*"));
        }
    }
}


13 Water Drop/Water Land/Pour Water
Input is a array represent how the height of water is at each position, the number of water will be poured, and the pour position. Print the land after all water are poured.

Example: input land height int[]{5,4,2,1,3,2,2,1,0,1,4,3} The land is looks ike:

+
++        +
++  +     ++
+++ +++   ++
++++++++ +++
++++++++++++
012345678901
water quantity is 8 and pour at position 5. The land becomes:

+
++        +
++www+    ++
+++w+++www++
++++++++w+++
++++++++++++
012345678901

package water_land;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class WaterLand {
    /*
        Water Land / Water Drop / Pour Water
        AirBnB Interview Question
     */
    public class Solution {
        public void pourWater(int[] heights, int location, int water) {
            int[] waters = new int[heights.length];
            int pourLocation;

            while (water > 0) {
                int left = location - 1;
                while (left >= 0) {
                    if (heights[left] + waters[left] > heights[left + 1] + waters[left + 1]) {
                        break;
                    }
                    left--;
                }
                if (heights[left + 1] + waters[left + 1] < heights[location] + waters[location]) {
                    pourLocation = left + 1;
                    waters[pourLocation]++;
                    water--;
                    continue;
                }

                int right = location + 1;
                while (right < heights.length) {
                    if (heights[right] + waters[right] > heights[right - 1] + waters[right - 1]) {
                        break;
                    }
                    right++;
                }
                if (heights[right - 1] + waters[right - 1] < heights[location] + waters[location]) {
                    pourLocation = right - 1;
                    waters[pourLocation]++;
                    water--;
                    continue;
                }

                pourLocation = location;
                waters[pourLocation]++;
                water--;
            }

            print(heights, waters);
        }

        private void print(int[] heights, int[] waters) {
            int n = heights.length;

            int maxHeight = 0;
            for (int i = 0; i < n; i++) {
                maxHeight = Math.max(maxHeight, heights[i] + waters[i]);
            }

            for (int height = maxHeight; height >= 0; height--) {
                for (int i = 0; i < n; i++) {
                    if (height <= heights[i]) {
                        System.out.print("+");
                    } else if (height > heights[i] && height <= heights[i] + waters[i]) {
                        System.out.print("W");
                    } else {
                        System.out.print(" ");
                    }
                }
                System.out.println();
            }
            System.out.println();
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new WaterLand().new Solution();
            int[] waterLand = new int[]{5, 4, 2, 1, 2, 3, 2, 1, 0, 1, 2, 4};
            sol.pourWater(waterLand, 5, 1);
            sol.pourWater(waterLand, 5, 5);
            sol.pourWater(waterLand, 5, 10);
            sol.pourWater(waterLand, 5, 20);
            sol.pourWater(waterLand, 5, 30);
            sol.pourWater(waterLand, 5, 50);
            sol.pourWater(waterLand, 5, 100);

            waterLand = new int[]{5, 4, 2, 1, 3, 2, 2, 1, 0, 1, 4, 3};
            sol.pourWater(waterLand, 4, 1);
            sol.pourWater(waterLand, 4, 5);
            sol.pourWater(waterLand, 4, 10);
            sol.pourWater(waterLand, 4, 20);
            sol.pourWater(waterLand, 4, 30);
            sol.pourWater(waterLand, 4, 50);
            sol.pourWater(waterLand, 4, 100);
        }
    }
}


14 Hilbert Curve
Given (x, y, iter), in which (x, y) is position at x-axis and y-axis, and iter is how many iterations will be. Output is in iteration iter, how many steps are required to move from (0, 0) to (x, y) in iteration iter.


package hilbert_curve;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class HilbertCurve {
    /*
        Hilbert Curve
        https://en.wikipedia.org/wiki/Hilbert_curve
        AirBnB Interview Question
     */
    public class Solution {
        public int hilbertCurve(int x, int y, int iter) {
            if (iter == 0) return 1;
            int len = 1 << (iter - 1);
            int num = 1 << (2 * (iter - 1));

            if (x >= len && y >= len) {
                // 3 Shape is identical with previous iteration
                return 2 * num + hilbertCurve(x - len, y - len, iter - 1);
            } else if (x < len && y >= len) {
                // 2 Shape is identical with previous iteration
                return num + hilbertCurve(x, y - len, iter - 1);
            } else if (x < len && y < len) {
                // 1 Clock-wise rotate 90
                return hilbertCurve(y, x, iter - 1);
            } else {
                // 4 Anti-Clockwise rotate 90
                return 3 * num + hilbertCurve(len - y - 1, 2 * len - x - 1, iter - 1);
            }
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new HilbertCurve().new Solution();
            assertEquals(3, sol.hilbertCurve(1, 1, 2));
            assertEquals(2, sol.hilbertCurve(0, 1, 1));
            assertEquals(9, sol.hilbertCurve(2, 2, 2));
        }
    }
}



15 Simulate Diplomacy
Input (army_name, location, action())

action() could be:

move(new_location) then army_name to new_location, If there is an army at new_location, then company strength of two aramy:
The army have higher strength stay at new_location, the lower army is disappeared.
If two army have the same strength, both are disppeared.
hold() stay at the same location
support(army_name) supoort another army. The supported army have one more strength.
The army's strength are intialized as the same.

16 Meeting Time
Input is a number of meetings (start_time, end_time)。 Output is a number of time intervals (start_time, end_time), where there is no meetings.

For exmaple, input is [[1, 3], [6, 7]], [[2, 4]], [[2, 3], [9, 12]] ]

output [[4, 6], [7, 9]]


package meeting_time;

import java.util.*;

import common.Interval;
import org.junit.*;

import static org.junit.Assert.*;

public class MeetingTime {

    /*
        Meeting Time
        AirBnB Interview Question
     */
    public class Solution {
        class Point implements Comparable<Point> {
            int time;
            boolean isStart;

            Point(int time, boolean isStart) {
                this.time = time;
                this.isStart = isStart;
            }

            @Override
            public int compareTo(Point that) {
                if (this.time != that.time || this.isStart == that.isStart) {
                    return this.time - that.time;
                } else {
                    return this.isStart ? -1 : 1;
                }
            }
        }

        public List<Interval> getAvailableIntervals(List<List<Interval>> intervals, int k) {
            List<Interval> res = new ArrayList<>();
            List<Point> points = new ArrayList<>();

            for (List<Interval> intervalList : intervals) {
                for (Interval interval : intervalList) {
                    points.add(new Point(interval.start, true));
                    points.add(new Point(interval.end, false));
                }
            }
            Collections.sort(points);

            int count = 0;
            Integer availableStart = null;
            for (int i = 0; i < points.size(); i++) {
                Point point = points.get(i);
                if (point.isStart) {
                    count++;
                    if (availableStart == null && i == 0 && count <= intervals.size() - k) {
                        availableStart = point.time;
                    } else if (availableStart != null && count == intervals.size() - k + 1) {
                        res.add(new Interval(availableStart, point.time));
                        availableStart = null;
                    }
                } else {
                    count--;
                    if (count == intervals.size() - k && i < points.size() - 1) {
                        availableStart = point.time;
                    } else if (availableStart != null && i == points.size() - 1 && count <= intervals.size() - k) {
                        res.add(new Interval(availableStart, point.time));
                        availableStart = null;
                    }
                }
            }

            return res;
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new MeetingTime().new Solution();
            List<List<Interval>> intervals = new ArrayList<List<Interval>>() {{
                add(new ArrayList<Interval>() {{
                    add(new Interval(1, 3));
                    add(new Interval(6, 7));
                }});
                add(new ArrayList<Interval>() {{
                    add(new Interval(2, 4));
                }});
                add(new ArrayList<Interval>() {{
                    add(new Interval(2, 3));
                    add(new Interval(9, 12));
                }});
            }};
            List<Interval> res = sol.getAvailableIntervals(intervals, 3);
            assertEquals(2, res.size());
            assertEquals(4, res.get(0).start);
            assertEquals(6, res.get(0).end);
            assertEquals(7, res.get(1).start);
            assertEquals(9, res.get(1).end);
        }
    }
}


17 Round Prices
Given an array of numbers A = [x1, x2, ..., xn] and T = Round(x1+x2+... +xn). We want to find a way to round each element in A such that after rounding we get a new array B = [y1, y2, ...., yn] such that y1+y2+...+yn = T where yi = Floor(xi) or Ceil(xi), ceiling or floor of xi.

We also want to minimize sum |x_i-y_i|

package round_prices;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class RoundPrices {
    /*
        Round Prices
        AirBnB Interview Question
     */
    public class Solution {
        public int[] roundUp(double[] arr) {
            int n = arr.length;
            NumWithDiff[] arrWithDiff = new NumWithDiff[n];
            double sum = 0.0;
            int floorSum = 0;
            for (int i = 0; i < n; i++) {
                int floor = (int) arr[i];
                int ceil = floor;
                if (floor < arr[i]) ceil++;
                floorSum += floor;
                sum += arr[i];
                arrWithDiff[i] = new NumWithDiff(ceil, ceil - arr[i]);
            }

            int num = (int) Math.round(sum);
            int diff = num - floorSum;
            Arrays.sort(arrWithDiff, new Comparator<NumWithDiff>() {
                @Override
                public int compare(NumWithDiff n1, NumWithDiff n2) {
                    if (n1.diffWithCeil <= n2.diffWithCeil) return -1;
                    else return 1;
                }
            });
            // Arrays.sort(arrWithDiff, (a, b) -> (Double.compare(b.diffWithCeil, a.diffWithCeil)));

            int[] res = new int[n];
            int i = 0;
            for (; i < diff; i++) {
                res[i] = arrWithDiff[i].num; // 这些放ceil
            }
            for (; i < n; i++) {
                res[i] = arrWithDiff[i].num - 1; // 剩下的只放floor
            }
            return res;
        }

        class NumWithDiff {
            int num;
            double diffWithCeil;

            public NumWithDiff(int n, double c) {
                this.num = n;
                this.diffWithCeil = c;
            }
        }
    }

    /*
        Round Prices
        AirBnB Interview Question
     */
    public class Solution_2 {
        public int[] roundUp(double[] prices) {
            if (prices == null || prices.length == 0) {
                return new int[0];
            }

            int[] res = new int[prices.length];

            double sum = 0;
            int roundSum = 0;
            Number[] numbers = new Number[prices.length];
            for (int i = 0; i < prices.length; i++) {
                numbers[i] = new Number(prices[i], i);
                sum += prices[i];
                roundSum += (int) Math.round(prices[i]);
                res[i] = (int) Math.round(prices[i]);
            }
            int sumRound = (int) Math.round(sum);

            if (sumRound == roundSum) {
                return res;
            } else if (sumRound > roundSum) {
                Arrays.sort(numbers, (a, b) -> (Double.compare(b.frac, a.frac)));
                int count = sumRound - roundSum;
                for (int i = 0; i < prices.length; i++) {
                    Number num = numbers[i];
                    if (num.frac < 0.5 && count > 0) {
                        res[num.index] = (int) Math.ceil(num.val);
                        count--;
                    } else {
                        res[num.index] = (int) Math.round(num.val);
                    }
                }
            } else {
                Arrays.sort(numbers, (a, b) -> (Double.compare(a.frac, b.frac)));
                int count = roundSum - sumRound;
                for (int i = 0; i < prices.length; i++) {
                    Number num = numbers[i];
                    if (num.frac >= 0.5 && count > 0) {
                        res[num.index] = (int) Math.floor(num.val);
                        count--;
                    } else {
                        res[num.index] = (int) Math.round(num.val);
                    }
                }
            }

            return res;
        }

        class Number {
            double val;
            double frac;
            int index;

            Number(double val, int index) {
                this.val = val;
                this.frac = val - Math.floor(val);
                this.index = index;
            }
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new RoundPrices().new Solution();
            double[] arr = {1.2, 3.7, 2.3, 4.8};
            int[] res = sol.roundUp(arr);
            assertEquals(5, res[0]);
            assertEquals(4, res[1]);
            assertEquals(2, res[2]);
            assertEquals(1, res[3]);

            arr = new double[]{1.2, 2.3, 3.4};
            res = sol.roundUp(arr);
            System.out.println(res);
            assertEquals(4, res[0]);
            assertEquals(2, res[1]);
            assertEquals(1, res[2]);

            arr = new double[]{1.2, 3.7, 2.3, 4.8};
            res = sol.roundUp(arr);
            assertEquals(5, res[0]);
            assertEquals(4, res[1]);
            assertEquals(2, res[2]);
            assertEquals(1, res[3]);

            arr = new double[]{1.2, 2.5, 3.6, 4.0};
            res = sol.roundUp(arr);
            assertEquals(4, res[0]);
            assertEquals(3, res[1]);
            assertEquals(2, res[2]);
            assertEquals(1, res[3]);
        }

        @Test
        public void test2() {
            Solution_2 sol = new RoundPrices().new Solution_2();
            double[] arr = {1.2, 2.3, 3.4};
            int[] res = sol.roundUp(arr);
            System.out.println(res);
            assertEquals(1, res[0]);
            assertEquals(2, res[1]);
            assertEquals(4, res[2]);

            arr = new double[]{1.2, 3.7, 2.3, 4.8};
            res = sol.roundUp(arr);
            assertEquals(1, res[0]);
            assertEquals(4, res[1]);
            assertEquals(2, res[2]);
            assertEquals(5, res[3]);

            arr = new double[]{1.2, 2.5, 3.6, 4.0};
            res = sol.roundUp(arr);
            assertEquals(1, res[0]);
            assertEquals(2, res[1]);
            assertEquals(4, res[2]);
            assertEquals(4, res[3]);

            arr = new double[]{2.5, 2.3, 3.1, 6.5};
            res = sol.roundUp(arr);
            assertEquals(2, res[0]);
            assertEquals(2, res[1]);
            assertEquals(3, res[2]);
            assertEquals(7, res[3]);

            arr = new double[]{2.9, 2.3, 1.4, 3, 6};
            res = sol.roundUp(arr);
            assertEquals(3, res[0]);
            assertEquals(2, res[1]);
            assertEquals(2, res[2]);
            assertEquals(3, res[3]);
            assertEquals(6, res[4]);

            arr = new double[]{-0.4, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3, 1.3};
            res = sol.roundUp(arr);
            assertEquals(0, res[0]);
            assertEquals(2, res[1]);
            assertEquals(2, res[2]);
            assertEquals(2, res[3]);
            assertEquals(1, res[4]);
            assertEquals(1, res[5]);
            assertEquals(1, res[6]);
            assertEquals(1, res[7]);
            assertEquals(1, res[8]);
            assertEquals(1, res[9]);
            assertEquals(1, res[10]);
        }
    }
}

18 Sliding Game
You're given a 3x3 board of a tile puzzle, with 8 tiles numbered 1 to 8, and an empty spot. You can move any tile adjacent to the empty spot, to the empty spot, creating an empty spot where the tile originally was. The goal is to find a series of moves that will solve the board, i.e. get [ [1, 2, 3], [4, 5, 6], [7, 8, - ]…

package sliding_game;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class SlidingGame {
    /*
        Sliding Game
        AirBnB Interview Question
     */
    public class Solution {
        private final int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        private int[][] matrix;
        private int m;
        private int n;
        private int originX;
        private int originY;
        private String recovered;

        public Solution(int[][] matrix) {
            this.matrix = matrix;
            this.m = matrix.length;
            this.n = matrix[0].length;
            int[][] recoveredMatrix = new int[m][n];
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (matrix[i][j] == 0) {
                        this.originX = i;
                        this.originY = j;
                    }

                    recoveredMatrix[i][j] = i * n + j;
                }
            }
            this.recovered = getMatrixString(recoveredMatrix);
        }

        public boolean canSolve() {
            Queue<int[]> items = new LinkedList<>();
            Queue<String> matrix = new LinkedList<>();
            Set<String> visited = new HashSet<>();

            String stringMatrix = getMatrixString(this.matrix.clone());
            items.offer(new int[]{originX, originY});
            matrix.offer(stringMatrix);
            visited.add(stringMatrix);

            while (!items.isEmpty()) {
                int size = items.size();
                for (int i = 0; i < size; i++) {
                    int[] curElement = items.poll();
                    String curMatrixString = matrix.poll();
                    int x = curElement[0];
                    int y = curElement[1];

                    if (curMatrixString.equals(recovered)) {
                        return true;
                    }

                    for (int k = 0; k < dirs.length; k++) {
                        int xx = x + dirs[k][0];
                        int yy = y + dirs[k][1];

                        if (xx < 0 || xx >= m || yy < 0 || yy >= n) {
                            continue;
                        }

                        int[][] newMatrix = recoverMatrixString(curMatrixString);
                        int temp = newMatrix[x][y];
                        newMatrix[x][y] = newMatrix[xx][yy];
                        newMatrix[xx][yy] = temp;
                        String newMatrixString = getMatrixString(newMatrix);
                        if (visited.contains(newMatrixString)) {
                            continue;
                        }

                        items.offer(new int[]{xx, yy});
                        matrix.offer(newMatrixString);
                        visited.add(newMatrixString);
                    }
                }
            }

            return false;
        }

        public List<String> getSolution() {
            String[] pathWord = {"Down", "Right", "Up", "Left"};

            Queue<int[]> items = new LinkedList<>();
            Queue<String> matrix = new LinkedList<>();
            Queue<List<String>> path = new LinkedList<>();
            Set<String> visited = new HashSet<>();

            String stringMatrix = getMatrixString(this.matrix.clone());
            items.offer(new int[]{originX, originY});
            matrix.offer(stringMatrix);
            path.offer(new ArrayList<>());
            visited.add(stringMatrix);

            while (!items.isEmpty()) {
                int size = items.size();
                for (int i = 0; i < size; i++) {
                    int[] curElement = items.poll();
                    String curMatrixString = matrix.poll();
                    List<String> curPath = path.poll();
                    int x = curElement[0];
                    int y = curElement[1];

                    if (curMatrixString.equals(recovered)) {
                        return curPath;
                    }

                    for (int k = 0; k < dirs.length; k++) {
                        int xx = x + dirs[k][0];
                        int yy = y + dirs[k][1];

                        if (xx < 0 || xx >= m || yy < 0 || yy >= n) {
                            continue;
                        }

                        int[][] newMatrix = recoverMatrixString(curMatrixString);
                        int temp = newMatrix[x][y];
                        newMatrix[x][y] = newMatrix[xx][yy];
                        newMatrix[xx][yy] = temp;
                        String newMatrixString = getMatrixString(newMatrix);
                        if (visited.contains(newMatrixString)) {
                            continue;
                        }

                        List<String> newPath = new ArrayList<>(curPath);
                        newPath.add(pathWord[k]);

                        items.offer(new int[]{xx, yy});
                        matrix.offer(newMatrixString);
                        path.offer(newPath);
                        visited.add(newMatrixString);
                    }
                }
            }

            return new ArrayList<>();
        }

        private String getMatrixString(int[][] matrix) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    sb.append(matrix[i][j]).append(",");
                }
            }
            return sb.toString();
        }

        private int[][] recoverMatrixString(String str) {
            String[] parts = str.split(",");
            int[][] res = new int[m][n];
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    res[i][j] = Integer.parseInt(parts[i * n + j]);
                }
            }
            return res;
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            int[][] matrix = {
                    {3, 1, 4},
                    {6, 2, 0},
                    {7, 5, 8}
            };
            Solution sol = new SlidingGame().new Solution(matrix);
            assertTrue(sol.canSolve());
            List<String> res = sol.getSolution();
            System.out.println(res);
            assertEquals(11, (int) res.size());
            assertEquals("Left", res.get(0));
            assertEquals("Down", res.get(1));
            assertEquals("Left", res.get(2));
            assertEquals("Up", res.get(3));
            assertEquals("Up", res.get(4));
            assertEquals("Right", res.get(5));
            assertEquals("Right", res.get(6));
            assertEquals("Down", res.get(7));
            assertEquals("Left", res.get(8));
            assertEquals("Up", res.get(9));
            assertEquals("Left", res.get(10));
        }
    }
}


19 Maximum Number of Nights You Can Accommodate
Given a set of numbers in an array which represent number of consecutive nights of AirBnB reservation requested, as a host, pick the sequence which maximizes the number of days of occupancy, at the same time, leaving at least 1 day gap in between bookings for cleaning. Problem reduces to finding max-sum of non-consecutive array elements.

package maximum_number_of_nights_you_can_accommodate;

import org.junit.*;

import static org.junit.Assert.*;

public class MaximumNumberofNightsYouCanAccommodate {
    /*
        Maximum Number a Night You Can Accommodate
        AirBnB Interview Question
    */
    public class Solution {
        public int rob(int[] nums) {
            if (nums == null) return 0;
            int n = nums.length;
            if (n == 0) return 0;
            if (n == 1) return nums[0];

            int f1 = nums[0]; // max sof far, excluding current
            int f2 = Math.max(nums[0], nums[1]); // max so far
            for (int i = 2; i < n; i++) {
                int f = Math.max(f1 + nums[i], f2);
                f1 = f2;
                f2 = f;
            }

            return f2;
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new MaximumNumberofNightsYouCanAccommodate().new Solution();
            int[] test1 = {5, 6, 3, 1};
            assertEquals(8, sol.rob(test1));
            int[] test2 = {6, 5, 0, 1, 0, 9};
            assertEquals(16, sol.rob(test2));
            int[] test3 = {5, 1, 1, 5};
            assertEquals(10, sol.rob(test3));
            int[] test4 = {3, 6, 4};
            assertEquals(7, sol.rob(test4));
            int[] test5 = {4, 10, 3, 1, 5};
            assertEquals(15, sol.rob(test5));
        }
    }
}

20 Find Case Combinations of a String
Find all the combinations of a string in lowercase and uppercase. For example, string "ab" >>> "ab", "Ab", "aB", "AB". So, you will have 2^n (n = number of chars in the string) output strings. The goal is for you to test each of these strings and see if it matchs a hidden string.

package find_case_combinations_of_a_string;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class FindCaseCombinationsofaString {
    /*
        Find Case Combinations of a String
        AirBnB Interview Question
     */
    public class Solution {
        private boolean isBitSet(int n, int offset) {
            return (n >> offset & 1) != 0;
        }

        public List<String> strComb(String text) {
            List<String> res = new ArrayList<>();
            if (text == null || text.length() == 0) {
                return res;
            }
            char[] chars = text.toCharArray();
            for (int i = 0, n = (int) Math.pow(2, chars.length); i < n; i++) {
                char[] curr = new char[chars.length];
                for (int j = 0; j < chars.length; j++) {
                    curr[j] = (isBitSet(i, j)) ? Character.toUpperCase(chars[j]) : Character.toLowerCase(chars[j]);
                }
                res.add(new String(curr));
            }
            return res;
        }

    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new FindCaseCombinationsofaString().new Solution();
            List<String> res = sol.strComb("AirBnB");
            assertEquals(64, res.size());
            assertEquals("airbnb", res.get(0));
            assertEquals("Airbnb", res.get(1));
            assertEquals("aIRBNB", res.get(62));
            assertEquals("AIRBNB", res.get(63));
        }
    }
}


21 Menu Combination Sum
Given a menu (list of items prices), find all possible combinations of items that sum a particular value K. (A variation of the typical 2sum/Nsum questions).

package menu_combination_sum;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class MenuCombinationSum {
    /*
        Menu Combination Sum
        AirBnB Interview Question
     */
    public class Solution {
        private void search(List<List<Double>> res, int[] centsPrices, int start, int centsTarget,
                            List<Double> curCombo, double[] prices) {
            if (centsTarget == 0) {
                res.add(new ArrayList<>(curCombo));
                return;
            }

            for (int i = start; i < centsPrices.length; i++) {
                if (i > start && centsPrices[i] == centsPrices[i - 1]) {
                    continue;
                }
                if (centsPrices[i] > centsTarget) {
                    break;
                }
                curCombo.add(prices[i]);
                search(res, centsPrices, i + 1, centsTarget - centsPrices[i], curCombo, prices);
                curCombo.remove(curCombo.size() - 1);
            }
        }

        public List<List<Double>> getCombos(double[] prices, double target) {
            List<List<Double>> res = new ArrayList<>();
            if (prices == null || prices.length == 0 || target <= 0) {
                return res;
            }

            int centsTarget = (int) Math.round(target * 100);
            Arrays.sort(prices);
            int[] centsPrices = new int[prices.length];
            for (int i = 0; i < prices.length; i++) {
                centsPrices[i] = (int) Math.round(prices[i] * 100);
            }

            search(res, centsPrices, 0, centsTarget, new ArrayList<>(), prices);
            return res;
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new MenuCombinationSum().new Solution();
            double[] prices = {10.02, 1.11, 2.22, 3.01, 4.02, 2.00, 5.03};
            List<List<Double>> combos = sol.getCombos(prices, 7.03);
            System.out.println(combos);
            assertEquals(2, combos.size());
        }
    }
}


22 K Edit Distance
Find all words from a dictionary that are k edit distance away.

package k_edit_distance;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class KEditDistance {
    /*
        K Edit Distance
        AirBnB Interview Question
     */
    public class Solution {
        private void search(String curr, String target, int k, TrieNode root,
                            int[] prevDist, List<String> result) {
            if (root.isLeaf) {
                if (prevDist[target.length()] <= k) {
                    result.add(curr);
                } else {
                    return;
                }
            }

            for (int i = 0; i < 26; i++) {
                if (root.children[i] == null) {
                    continue;
                }

                int[] currDist = new int[target.length() + 1];
                currDist[0] = curr.length() + 1;
                for (int j = 1; j < prevDist.length; j++) {
                    if (target.charAt(j - 1) == (char) (i + 'a')) {
                        currDist[j] = prevDist[j - 1];
                    } else {
                        currDist[j] = Math.min(Math.min(prevDist[j - 1], prevDist[j]), currDist[j - 1]) + 1;
                    }
                }

                search(curr + (char) (i + 'a'), target, k, root.children[i], currDist, result);
            }
        }

        public List<String> getKEditDistance(String[] words, String target, int k) {
            List<String> res = new ArrayList<>();
            if (words == null || words.length == 0 || target == null ||
                    target.length() == 0 || k < 0) {
                return res;
            }

            Trie trie = new Trie();
            for (String word : words) {
                trie.insert(word);
            }

            TrieNode root = trie.root;
            // The edit distance from curr to target
            int[] prev = new int[target.length() + 1];
            for (int i = 0; i < prev.length; i++) {
                prev[i] = i;
            }

            search("", target, k, root, prev, res);

            return res;
        }

        class TrieNode {
            TrieNode[] children;
            boolean isLeaf;

            public TrieNode() {
                children = new TrieNode[26];
            }
        }

        class Trie {
            TrieNode root;

            public Trie() {
                root = new TrieNode();
            }

            // Add a word into trie
            public void insert(String s) {
                if (s == null || s.length() == 0) {
                    return;
                }

                TrieNode p = root;
                for (int i = 0; i < s.length(); i++) {
                    char c = s.charAt(i);
                    if (p.children[c - 'a'] == null) {
                        p.children[c - 'a'] = new TrieNode();
                    }

                    if (i == s.length() - 1) {
                        p.children[c - 'a'].isLeaf = true;
                    }

                    p = p.children[c - 'a'];
                }
            }
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new KEditDistance().new Solution();
            String[] input = new String[]{"abcd", "abc", "abd", "ad", "c", "cc"};
            String target = "abcd";
            int k = 2;
            List<String> res = sol.getKEditDistance(input, target, k);
            assertEquals(4, res.size());
        }
    }
}



23 Boggle Game
Given 2d matrix of letters, and a word dictionary, find a path which has largest number of words (existed inside the dictionary).

package boggle_game;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class BoggleGame {
    /*
        Boggle Game
        AirBnB Interview Question
     */
    public class Solution {
        private final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        private String path2Word(char[][] board, List<int[]> curPath) {
            StringBuilder sb = new StringBuilder();
            for (int[] coor : curPath) {
                sb.append(board[coor[0]][coor[1]]);
            }
            return sb.toString();
        }

        private void search(List<List<int[]>> paths, char[][] board, int x, int y, Trie trie,
                            boolean[][] visited, List<int[]> curPath) {
            String curWord = path2Word(board, curPath);
            ReturnType flag = trie.search(curWord);
            if (!flag.hasPrefix) {
                return;
            }
            if (flag.hasWord) {
                paths.add(new ArrayList<>(curPath));
            }

            int m = board.length;
            int n = board[0].length;

            for (int[] dir : dirs) {
                int xx = x + dir[0];
                int yy = y + dir[1];

                if (xx < 0 || xx >= m || yy < 0 || yy >= n) {
                    continue;
                }

                visited[xx][yy] = true;
                curPath.add(new int[]{xx, yy});
                search(paths, board, xx, yy, trie, visited, curPath);
                curPath.remove(curPath.size() - 1);
                visited[xx][yy] = false;
            }
        }

        private void searchWords(List<String> res, List<String> curWords, List<List<int[]>> paths,
                                 int start, boolean[][] visited, char[][] board) {
            if (start == paths.size()) {
                if (curWords.size() > res.size()) {
                    res.clear();
                    res.addAll(curWords);
                }
                return;
            }

            for (int i = start; i < paths.size(); i++) {
                boolean canUse = true;
                for (int[] coor : paths.get(i)) {
                    if (visited[coor[0]][coor[1]]) {
                        canUse = false;
                        break;
                    }
                }

                if (canUse) {
                    for (int[] coor : paths.get(i)) {
                        visited[coor[0]][coor[1]] = true;
                    }
                    curWords.add(path2Word(board, paths.get(i)));
                    searchWords(res, curWords, paths, i + 1, visited, board);
                    curWords.remove(curWords.size() - 1);
                    for (int[] coor : paths.get(i)) {
                        visited[coor[0]][coor[1]] = false;
                    }
                }
            }
        }

        public List<String> findMostStr(char[][] board, Set<String> dict) {
            List<List<int[]>> paths = new ArrayList<>();

            Trie trie = new Trie();
            for (String word : dict) {
                trie.insert(word);
            }

            int m = board.length;
            int n = board[0].length;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    boolean[][] visited = new boolean[m][n];
                    visited[i][j] = true;
                    List<int[]> curPath = new ArrayList<>();
                    curPath.add(new int[]{i, j});
                    search(paths, board, i, j, trie, visited, curPath);
                }
            }

            List<String> res = new ArrayList<>();
            searchWords(res, new ArrayList<>(), paths, 0, new boolean[m][n], board);

            return res;
        }

        class ReturnType {
            boolean hasPrefix;
            boolean hasWord;

            ReturnType(boolean hasPrefix, boolean hasWord) {
                this.hasPrefix = hasPrefix;
                this.hasWord = hasWord;
            }
        }

        class TrieNode {
            char c;
            boolean isEnd;
            Map<Character, TrieNode> children;

            public TrieNode(char c, boolean isEnd) {
                this.c = c;
                this.isEnd = isEnd;
                this.children = new HashMap<>();
            }
        }

        class Trie {
            private TrieNode root;

            public Trie() {
                this.root = new TrieNode(' ', false);
            }

            public void insert(String word) {
                TrieNode cur = root;
                for (int i = 0; i < word.length(); i++) {
                    char c = word.charAt(i);
                    if (!cur.children.containsKey(c)) {
                        cur.children.put(c, new TrieNode(c, false));
                    }
                    cur = cur.children.get(c);
                }
                cur.isEnd = true;
            }

            public ReturnType search(String word) {
                TrieNode cur = root;
                for (int i = 0; i < word.length(); i++) {
                    char c = word.charAt(i);
                    if (!cur.children.containsKey(c)) {
                        return new ReturnType(false, false);
                    }
                    cur = cur.children.get(c);
                }
                return new ReturnType(true, cur.isEnd);
            }
        }
    }


    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new BoggleGame().new Solution();
            char[][] board = {
                    {'o', 'a', 't', 'h'},
                    {'e', 't', 'a', 'e'},
                    {'i', 'h', 'k', 'r'},
                    {'i', 'f', 'l', 'v'}
            };
            Set<String> dict = new HashSet<>();
            dict.add("oath");
            dict.add("pea");
            dict.add("eat");
            dict.add("rain");
            List<String> res = sol.findMostStr(board, dict);
            assertEquals(2, res.size());
            assertEquals("oath", res.get(0));
            assertEquals("eat", res.get(1));
        }
    }
}


24 Minimum Cost with At Most K Stops
Given a flight itinerary consisting of starting city, destination city, and ticket price (2d list) - find the optimal price flight path to get from start to destination. (A variation of Dynamic Programming Shortest Path)

package minimum_cost_with_at_most_k_stops;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class MinimumCostwithAtMostKStops {
    /*
        Minimum Cost with At Most K Stops - BFS
        AirBnB Interview Question
     */
    public class Solution {
        public int minCost(List<String> lines, String source, String target, int k) {
            if (lines.size() == 0 || k < 0) {
                return 0;
            }
            Map<String, Flight> nodes = new HashMap<>();
            for (String line : lines) {
                String[] s = line.trim().split(",");
                String[] t = s[0].trim().split("->");
                String from = t[0];
                String to = t[1];
                int cost = Integer.valueOf(s[1].trim());
                if (!nodes.containsKey(from)) nodes.put(from, new Flight(from));
                if (!nodes.containsKey(to)) nodes.put(to, new Flight(to));
                nodes.get(from).nextNodes.put(to, cost);
            }

            boolean find = false;
            Queue<String> q = new LinkedList<>();
            Queue<Integer> cost = new LinkedList<>();
            q.offer(source);
            cost.offer(0);
            int stops = -1;
            while (!q.isEmpty()) {
                stops++;
                if (stops > k + 1) {
                    break;
                }
                int qSize = q.size();
                for (int i = 0; i < qSize; i++) {
                    Flight curr = nodes.get(q.poll());
                    int currCost = cost.poll();
                    curr.minCost = Math.min(curr.minCost, currCost);

                    if (curr.name.equals(target)) {
                        find = true;
                        continue;
                    }

                    for (String next : curr.nextNodes.keySet()) {
                        int nextCost = currCost + curr.nextNodes.get(next);
                        if (nextCost < nodes.get(next).minCost && (stops < k || stops == k && next.equals(target))) {
                            q.offer(next);
                            cost.offer(nextCost);
                        }
                    }
                }
            }

            return find ? nodes.get(target).minCost : -1;
        }
    }

    class Flight {
        String name;
        int minCost;
        Map<String, Integer> nextNodes;

        Flight(String name) {
            this.name = name;
            this.minCost = Integer.MAX_VALUE;
            this.nextNodes = new HashMap<>();
        }
    }


    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new MinimumCostwithAtMostKStops().new Solution();
            List<String> lines = new ArrayList<>();
            lines.add("A->B,100");
            lines.add("A->C,400");
            lines.add("B->C,100");
            lines.add("C->D,100");
            lines.add("C->A,10");
            assertEquals(-1, sol.minCost(lines, "A", "D", 0));
            assertEquals(500, sol.minCost(lines, "A", "D", 1));
            assertEquals(300, sol.minCost(lines, "A", "D", 2));
        }
    }
}


25 String Pyramids Transition Matrix
Given a list of leaf nodes in a pyramid, and a map which indicates what's the possible parent node given a left and right node. Return true if the one of leaf node could turn into the root node, Otherwise, return false. For example:

     root
     / \
    X   X
   /\  /\
   X  X  X
  / \/ \/ \
 A   B  C  D
Map:

        left: A |  B   |   C | D
right---------------------------------
A             B |A or C|   D | A
B             D |B or C|   A |
C                              B
D
Note:1. If left child is B, right child is A, the parent node could be B or C

Given leaf input of "ABCD", output true.

package string_pyramids_transition_matrix;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class StringPyramidsTransitionMatrix {
    /*
        String Pyramids Transition Matrix
        AirBnB Interview Question
     */
    public class Solution {
        Map<String, Set<Character>> map;
        private Map<String, Boolean> cache;
        final String SEP = "###";

        Solution(String[] line) {
            cache = new HashMap<>();
            map = new HashMap<>();
            for (String s : line) {
                String[] splitted = s.split(",");
                String key = splitted[0] + SEP + splitted[1];
                Set<Character> set = new HashSet<>();
                for (char c : splitted[2].toCharArray())
                    set.add(c);
                map.put(key, set);
            }
        }

        private void getNextLevel(List<String> res, String curr, int start, StringBuilder sb) {
            if (start == curr.length() - 1) {
                res.add(new String(sb));
                return;
            }
            for (int i = start; i < curr.length() - 1; i++) {
                String key = curr.charAt(i) + SEP + curr.charAt(i + 1);
                for (char c : map.get(key)) {
                    sb.append(c);
                    getNextLevel(res, curr, start + 1, sb);
                    sb.setLength(sb.length() - 1);
                }
            }
        }

        private boolean search(String input, String current) {
            if (cache.containsKey(input)) return cache.get(input);
            if (current.length() == 1) {
                cache.put(current, input.contains(current));
                return cache.get(current);
            }

            List<String> cands = new ArrayList<>();
            getNextLevel(cands, current, 0, new StringBuilder());
            for (String cand : cands) {
                // System.out.println(cand);
                if (cache.containsKey(cand)) return cache.get(cand);
                boolean res = search(input, cand);
                if (res) {
                    cache.put(cand, true);
                    return true;
                }
            }

            return false;
        }

        public boolean check(String input) {
            cache.clear();
            return search(input, input);
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            String[] lines = {
                    "A,A,AC", "A,B,CD", "A,C,D", "A,D,B",
                    "B,A,B", "B,B,C", "B,C,A", "B,D,CD",
                    "C,A,A", "C,B,C", "C,C,D", "C,D,B",
                    "D,A,BC", "D,B,D", "D,C,A", "D,D,C"
            };
            Solution sol = new StringPyramidsTransitionMatrix().new Solution(lines);
            // sol.check("ABCD");
            assertTrue(sol.check("ABCD"));
            assertTrue(sol.check("AACC"));
            assertTrue(sol.check("AAAA"));
            assertFalse(sol.check("CCCC"));
            assertFalse(sol.check("DDDD"));
        }
    }
}


26 Finding Ocean
Given: An array of strings where L indicates land and W indicates water, and a coordinate marking a starting point in the middle of the ocean.

Challenge: Find and mark the ocean in the map by changing appropriate Ws to Os.

An ocean coordinate is defined to be the initial coordinate if a W, and
any coordinate directly adjacent to any other ocean coordinate.
void findOcean(String[] map, int row, int column);
String[] map = new String[]{
 "WWWLLLW",
 "WWLLLWW",
 "WLLLLWW"
};
printMap(map);
STDOUT:
WWWLLLW
WWLLLWW
WLLLLWW
findOcean(map, 0, 1);
printMap(map);
STDOUT:
OOOLLLW
OOLLLWW
OLLLLWW

package finding_ocean;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class FindingOcean {
    /*
        Finding Ocean
        AirBnB Interview Question
     */
    public class Solution {
        public void floodFill(char[][] board, int i, int j, char oldColor, char newColor) {
            if (board[i][j] != oldColor || board[i][j] == newColor) {
                return;
            }

            Queue<Integer> queue = new LinkedList<>();
            queue.add(i * board[0].length + j);
            board[i][j] = newColor;

            while (!queue.isEmpty()) {
                int pos = queue.poll();
                int m = pos / board[0].length;
                int n = pos % board[0].length;

                if (m + 1 < board.length && board[m + 1][n] == oldColor) {
                    queue.add((m + 1) * board[0].length + n);
                    board[m + 1][n] = newColor;
                }
                if (m - 1 >= 0 && board[m - 1][n] == oldColor) {
                    queue.add((m - 1) * board[0].length + n);
                    board[m - 1][n] = newColor;
                }
                if (n + 1 < board[0].length && board[m][n + 1] == oldColor) {
                    queue.add(m * board[0].length + n + 1);
                    board[m][n + 1] = newColor;
                }
                if (n - 1 >= 0 && board[m][n - 1] == oldColor) {
                    queue.add(m * board[0].length + n - 1);
                    board[m][n - 1] = newColor;
                }
            }
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new FindingOcean().new Solution();
            List<String> testData = new ArrayList<String>() {{
                add("WWWLLLW");
                add("WWLLLWW");
                add("WLLLLWW");
            }};
            char[][] map = new char[testData.size()][testData.get(0).length()];
            for (int i = 0; i < testData.size(); i++)
                for (int j = 0; j < testData.get(i).length(); j++)
                    map[i][j] = testData.get(i).charAt(j);

            sol.floodFill(map, 0, 0, 'W', 'O');
            assertEquals('O', map[0][0]);


            testData = new ArrayList<String>() {{
                add("LLLLLLLLLLLLLLLLLLLL");
                add("LLLLLLLLLLLLLLLLLLLL");
                add("LLLLLLLLLLLLLLWLLLLL");
                add("LLWWLLLLLLLLLLLLLLLL");
                add("LLWWLLLLLLLLLLLLLLLL");
                add("LLLLLLLLLLLLLLLLLLLL");
                add("LLLLLLLWWLLLLLLLLLLL");
                add("LLLLLLLLWWLLLLLLLLLL");
                add("LLLLLLLLLWWWLLLLLLLL");
                add("LLLLLLLLLLWWWWWWLLLL");
                add("LLLLLLLLLLWWWWWWLLLL");
                add("LLLLLLLLLLWWWWWWLLLL");
                add("LLLLWWLLLLWWWWWWLLLL");
                add("LLLLWWWLLLWWWWWWWWWW");
                add("LLLLLWWWWWWWWWWWLLLL");
                add("LLLLLLLLLLLLLLWWWWLL");
                add("LLLLLLLLLLLLLLWLLLLL");
                add("LLLLWLLLLLLLLLLLLWLL");
                add("LLLLLLLLLLLLLLLLLLWL");
            }};

            map = new char[testData.size()][testData.get(0).length()];
            for (int i = 0; i < testData.size(); i++)
                for (int j = 0; j < testData.get(i).length(); j++)
                    map[i][j] = testData.get(i).charAt(j);
            sol.floodFill(map, 9, 12, 'W', 'O');
            assertEquals('O', map[9][11]);
        }
    }
}


27 Preference List
Given a list of everyone's preferred city list, output the city list following the order of everyone's preference order.

For example, input is [[3, 5, 7, 9], [2, 3, 8], [5, 8]]. One of possible output is [2, 3, 5, 8, 7, 9].

package preference_list;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class PreferenceList {
    /*
        Preference List
        AirBnB Interview Question
     */
    public class Solution {
        public List<Integer> getPreference(List<List<Integer>> preferences) {
            Map<Integer, Integer> inDegree = new HashMap<>();
            Map<Integer, Set<Integer>> nodes = new HashMap<>();
            for (List<Integer> l : preferences) {
                for (int i = 0; i < l.size() - 1; i++) {
                    int from = l.get(i);
                    int to = l.get(i + 1);
                    if (!nodes.containsKey(from)) {
                        inDegree.put(from, 0);
                        nodes.put(from, new HashSet<>());
                    }
                    if (!nodes.containsKey(to)) {
                        inDegree.put(to, 0);
                        nodes.put(to, new HashSet<>());
                    }
                    if (!nodes.get(from).contains(to)) {
                        Set<Integer> s = nodes.get(from);
                        s.add(to);
                        nodes.put(from, s);
                    }
                    inDegree.put(to, inDegree.getOrDefault(to, 0) + 1);
                }
            }
            Queue<Integer> q = new LinkedList<>();
            for (int k : inDegree.keySet()) {
                if (inDegree.get(k) == 0) {
                    q.offer(k);
                }
            }
            List<Integer> res = new ArrayList<>();
            while (!q.isEmpty()) {
                int id = q.poll();
                res.add(id);
                Set<Integer> neighbors = nodes.get(id);
                for (int next : neighbors) {
                    int degree = inDegree.get(next) - 1;
                    inDegree.put(next, degree);
                    if (degree == 0) q.offer(next);
                }
            }
            return res;
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new PreferenceList().new Solution();
            List<List<Integer>> preferences = new ArrayList<>();
            List<Integer> p1 = new ArrayList<Integer>() {{
                add(2);
                add(3);
                add(5);
            }};
            List<Integer> p2 = new ArrayList<Integer>() {{
                add(4);
                add(2);
                add(1);
            }};
            List<Integer> p3 = new ArrayList<Integer>() {{
                add(4);
                add(1);
                add(5);
                add(6);
            }};
            List<Integer> p4 = new ArrayList<Integer>() {{
                add(4);
                add(7);
            }};
            preferences.add(p1);
            preferences.add(p2);
            preferences.add(p3);
            preferences.add(p4);
            List<Integer> res = sol.getPreference(preferences);
            // System.out.println(res);
            assertEquals(7, res.size());
            assertEquals(4, (int) res.get(0));
            assertEquals(2, (int) res.get(1));
            assertEquals(7, (int) res.get(2));
            assertEquals(1, (int) res.get(3));
            assertEquals(3, (int) res.get(4));
            assertEquals(5, (int) res.get(5));
            assertEquals(6, (int) res.get(6));

            p1 = new ArrayList<Integer>() {{
                add(3);
                add(5);
                add(7);
                add(9);
            }};
            p2 = new ArrayList<Integer>() {{
                add(2);
                add(3);
                add(8);
            }};
            p3 = new ArrayList<Integer>() {{
                add(5);
                add(8);
            }};
            preferences = new ArrayList<>();
            preferences.add(p1);
            preferences.add(p2);
            preferences.add(p3);
            res = sol.getPreference(preferences);
            // System.out.println(res);
            assertEquals(6, res.size());
        }
    }
}


28 Minimum Vertices to Traverse Directed Graph
Given a directed grapjh, represented in a two dimension array, output a list of points that can be used to travese every points with the least number of visited vertices.

package minimum_vertices_to_traverse_directed_graph;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class MinimumVerticestoTraverseDirectedGraph {
    /*
        Minimum Vertices to Traverse Directed Graph - DFS
        https://cs.stackexchange.com/questions/1698/find-the-minimal-number-of-runs-to-visit-every-edge-of-a-directed-graph
        AirBnB Interview Question
     */
    public class Solution {
        private void search(Set<Integer> res, Map<Integer, Set<Integer>> nodes, int cur, int start,
                            Set<Integer> visited, Set<Integer> currVisited) {
            currVisited.add(cur);
            visited.add(cur);
            for (int next : nodes.get(cur)) {
                if (res.contains(next) && next != start) {
                    res.remove(next);
                }
                if (!currVisited.contains(next)) {
                    search(res, nodes, next, start, visited, currVisited);
                }
            }
        }

        public List<Integer> getMin(int[][] edges, int n) {
            Map<Integer, Set<Integer>> nodes = new HashMap<>();
            for (int i = 0; i < n; i++) {
                nodes.put(i, new HashSet<>());
            }
            for (int[] edge : edges) {
                nodes.get(edge[0]).add(edge[1]);
            }

            Set<Integer> visited = new HashSet<>();
            Set<Integer> res = new HashSet<>();
            for (int i = 0; i < n; i++) {
                if (!visited.contains(i)) {
                    res.add(i);
                    visited.add(i);
                    search(res, nodes, i, i, visited, new HashSet<>());
                }
            }

            return new ArrayList<>(res);
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new MinimumVerticestoTraverseDirectedGraph().new Solution();
            ////    1->2->3->1, 2->0->0
            ////      0  1  2  3
            ////    0[1, 0, 0, 0]
            ////    1[0, 0, 1, 0]
            ////    2[1, 0, 0, 1]
            ////    3[0, 1, 0, 0]
            int[][] edges = {{0, 0}, {1, 2}, {2, 0}, {2, 3}, {3, 1}};
            List<Integer> res = sol.getMin(edges, 4);
            System.out.println(res);
            assertEquals(1, res.size());

            ////    0->1->0, 2->3->2->1
            ////      0  1  2  3
            ////    0[0, 1, 0, 0]
            ////    1[1, 0, 0, 0]
            ////    2[0, 1, 0, 1]
            ////    3[0, 0, 1, 0]
            edges = new int[][]{{0, 1}, {1, 0}, {2, 1}, {2, 3}, {3, 2}};
            res = sol.getMin(edges, 4);
            System.out.println(res);
            assertEquals(1, res.size());

            ////    3->2->1->0  0->1 3->1
            ////      0  1  2  3
            ////    0[0, 1, 0, 0]
            ////    1[1, 0, 0, 0]
            ////    2[0, 1, 0, 0]
            ////    3[0, 1, 1, 0]
            edges = new int[][]{{0, 1}, {1, 0}, {2, 1}, {3, 1}, {3, 2}};
            res = sol.getMin(edges, 4);
            System.out.println(res);
            assertEquals(1, res.size());

            ////      0  1  2  3  4  5  6  7  8  9
            ////    0[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ////    1[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ////    2[0, 0, 0 ,0, 0, 0, 0, 0, 0, 1]
            ////    3[0, 0, 0, 1, 0, 1, 0, 1, 0, 0]
            ////    4[0, 0, 0, 0, 0, 0 ,0, 0, 1, 0]
            ////    5[0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
            ////    6[0, 0, 0, 0, 0, 0, 1, 0, 0 ,0]
            ////    7[0, 0, 0, 0, 1, 0, 0, 0, 0, 0]
            ////    8[0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
            ////    9[0, 0, 0, 1, 0, 0, 1, 0, 0, 0]
            edges = new int[][]{{2, 9}, {3, 3}, {3, 5}, {3, 7}, {4, 8}, {5, 8}, {6, 6}, {7, 4}, {8, 7}, {9, 3}, {9, 6}};
            res = sol.getMin(edges, 10);
            System.out.println(res);
            assertEquals(3, res.size());
        }
    }
}

29 10 Wizards
There are 10 wizards, 0-9, you are given a list that each entry is a list of wizards known by wizard. Define the cost between wizards and wizard as square of different of i and j. To find the min cost between 0 and 9.

For example:

wizard[0] list: 1, 4, 5 

wizard[4] list: 9

 wizard 0 to 9 min distance is (0-4)^2+(4-9)^2=41 (wizard[0]->wizard[4]->wizard[9])

package ten_wizards;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class TenWizards {
    /*
        Ten Wizards - BFS
        AirBnB Interview Question
     */
    public class Solution {
        public List<Integer> getShortestPath(List<List<Integer>> wizards, int source, int target) {
            int n = wizards.size();
            int[] parents = new int[wizards.size()];
            Map<Integer, Wizard> map = new HashMap<>();
            for (int i = 0; i < n; i++) {
                parents[i] = i;
                map.put(i, new Wizard(i));
            }

            map.get(source).dist = 0;
            Queue<Wizard> queue = new LinkedList<>();
            queue.offer(map.get(source));
            while (!queue.isEmpty()) {
                Wizard curr = queue.poll();
                List<Integer> neighbors = wizards.get(curr.id);
                for (int neighbor : neighbors) {
                    Wizard next = map.get(neighbor);
                    int weight = (int) Math.pow(next.id - curr.id, 2);
                    if (curr.dist + weight < next.dist) {
                        parents[next.id] = curr.id;
                        next.dist = curr.dist + weight;
                        // queue.offer(next);
                    }
                    queue.offer(next);
                }
            }

            List<Integer> res = new ArrayList<>();
            int t = target;
            while (t != source) {
                res.add(t);
                t = parents[t];
            }
            res.add(source);

            Collections.reverse(res);
            return res;
        }
    }

    class Wizard implements Comparable<Wizard> {
        int id;
        int dist;
        // Map<Integer, Integer> costs;

        Wizard(int id) {
            this.id = id;
            this.dist = Integer.MAX_VALUE;
            // this.costs = new HashMap<>();
        }

        @Override
        public int compareTo(Wizard that) {
            return this.dist - that.dist;
        }
    }

    /*
        Ten Wizards - Dijkstra
        AirBnB Interview Question
     */
    public class Solution_2 {
        public List<Integer> getShortestPath(List<List<Integer>> wizards, int source, int target) {
            if (wizards == null || wizards.size() == 0) return null;
            int n = wizards.size();
            int[] parent = new int[n];
            Map<Integer, Wizard> map = new HashMap<>();
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                map.put(i, new Wizard(i));
            }

            map.get(source).dist = 0;
            Queue<Wizard> pq = new PriorityQueue<>(n);
            pq.offer(map.get(source));
            while (!pq.isEmpty()) {
                Wizard curr = pq.poll();
                List<Integer> neighbors = wizards.get(curr.id);
                for (int neighbor : neighbors) {
                    Wizard next = map.get(neighbor);
                    int weight = (int) Math.pow(next.id - curr.id, 2);
                    if (curr.dist + weight < next.dist) {
                        parent[next.id] = curr.id;
                        pq.remove(next);
                        next.dist = curr.dist + weight;
                        pq.offer(next);
                    }
                }
            }

            List<Integer> res = new ArrayList<>();
            int t = target;
            while (t != source) {
                res.add(t);
                t = parent[t];
            }
            res.add(source);
            Collections.reverse(res);
            return res;
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new TenWizards().new Solution();
            int[][] ids = {{1, 5, 9}, {2, 3, 9}, {4}, {}, {}, {9}, {}, {}, {}, {}};
            List<List<Integer>> wizards = new ArrayList<>();
            for (int i = 0; i < ids.length; i++) {
                List<Integer> wizard = new ArrayList<>();
                for (int j = 0; j < ids[i].length; j++) {
                    wizard.add(ids[i][j]);
                }
                wizards.add(wizard);
            }
            List<Integer> res = sol.getShortestPath(wizards, 0, 9);
            assertEquals(3, res.size());
            assertEquals(0, (int) res.get(0));
            assertEquals(5, (int) res.get(1));
            assertEquals(9, (int) res.get(2));
        }

        @Test
        public void test2() {
            Solution_2 sol = new TenWizards().new Solution_2();
            int[][] ids = {{1, 5, 9}, {2, 3, 9}, {4}, {}, {}, {9}, {}, {}, {}, {}};
            List<List<Integer>> wizards = new ArrayList<>();
            for (int i = 0; i < ids.length; i++) {
                List<Integer> wizard = new ArrayList<>();
                for (int j = 0; j < ids[i].length; j++) {
                    wizard.add(ids[i][j]);
                }
                wizards.add(wizard);
            }
            List<Integer> res = sol.getShortestPath(wizards, 0, 9);
            assertEquals(3, res.size());
            assertEquals(0, (int) res.get(0));
            assertEquals(5, (int) res.get(1));
            assertEquals(9, (int) res.get(2));
        }
    }
}


30 Number of Intersected Rectangles
Given lots of rectangles, output how many of them intersect.
package number_of_intersected_rectangles;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class NumberofIntersectedRectangles {
    /*
        Number of Intersected Rectangles - Union Find
        AirBnB Interview Question
     */
    public class Solution {
        private boolean intersect(int[][] r1, int[][] r2) {
            return r1[0][0] < r2[0][0] && r1[0][1] < r2[0][1] && r2[0][0] < r1[1][0] && r2[0][1] < r1[1][1] ||
                    r1[0][0] < r2[1][0] && r1[0][1] < r2[1][1] && r2[1][0] < r1[1][0] && r2[1][1] < r1[1][1];
        }

        private int find(int val, int[] parents) {
            while (parents[val] != val) {
                val = parents[val];
            }
            return val;
        }

        public int countIntersection(int[][][] rectangles) {
            if (rectangles == null || rectangles.length == 0) return 0;
            int n = rectangles.length;
            int[] parents = new int[n];
            for (int i = 0; i < n; i++) {
                parents[i] = i;
            }
            for (int i = 0; i < n - 1; i++) {
                for (int j = i + 1; j < n; j++) {
                    if (intersect(rectangles[i], rectangles[j])) {
                        int root1 = find(i, parents);
                        int root2 = find(j, parents);

                        if (root1 != root2) {
                            parents[root1] = root2;
                        }
                    }
                }
            }

            Set<Integer> set = new HashSet<>();
            for (int i = 0; i < n; i++) {
                set.add(find(i, parents));
            }

            return set.size();
        }
    }

    public static class UnitTest {
        @Test
        public void test1() {
            Solution sol = new NumberofIntersectedRectangles().new Solution();
            int[][][] rectangles = {
                    {{-3, -2}, {2, 1}},
                    {{10, 8}, {15, 10}},
                    {{1, 0}, {7, 4}},
                    {{12, 9}, {16, 12}},
                    {{-2, -1}, {5, 3}}
            };
            assertEquals(2, sol.countIntersection(rectangles));
        }
    }
}


31 Guess Number
The system has a secret four digits number, in which each digit is in range of one to 6 [1, 6].

Given a four digital number, the system also provide a API that returns the number of correct matched digits.

Design a method to guess this secret number.

package guess_number;

import java.util.*;

import org.junit.*;

import static org.junit.Assert.*;

public class GuessNumber {
    /*
        Guess Number
        AirBnB Interview Question
     */
    public class Solution {
        String target;

        public Solution(String target) {
            this.target = target;
        }

        private int guessServer(String guess) {
            int res = 0;
            Map<Character, Integer> targetMap = new HashMap<>();
            for (char c : target.toCharArray()) targetMap.put(c, targetMap.getOrDefault(c, 0) + 1);
            Map<Character, Integer> guessMap = new HashMap<>();
            for (char c : guess.toCharArray()) guessMap.put(c, guessMap.getOrDefault(c, 0) + 1);
            for (char k : guessMap.keySet()) {
                if (targetMap.containsKey(k))
                    res += Math.min(guessMap.get(k), targetMap.get(k));
            }
            return res;
        }

        private String genNumber(List<Integer> guessed, int c) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < guessed.size(); i++)
                sb.append(guessed.get(i));
            for (int i = guessed.size(); i < 4; i++)
                sb.append(c);
            return sb.toString();
        }

        private String genNumber(List<Integer> guessed) {
            if (guessed == null || guessed.size() == 0) return "";
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < guessed.size(); i++)
                sb.append(guessed.get(i));
            return sb.toString();
        }

        public String guess() {
            List<Integer> res = new ArrayList<>();
            List<Integer> cands = new ArrayList<Integer>() {{
                add(1);
                add(2);
                add(3);
                add(4);
                add(5);
                // insert(6);
            }};
            // System.out.println("\nstart to guess " + target + " ...");
            // System.out.println("res: " + res);
            // System.out.println("candList: " + candList);
            int counter = 0;
            Iterator<Integer> iter = cands.iterator();
            while (iter.hasNext() && res.size() < 4) {
                int cand = iter.next();
                counter++;
                int guessedCount = res.size();
                String guessCand = genNumber(res, cand);
                int guessRes = guessServer(guessCand);
                // System.out.println("cand: " + cand);
                // System.out.println("guessRes: " + guessRes);
                if (guessRes == guessedCount) {
                    iter.remove();
                } else if (guessRes > guessedCount) {
                    for (int i = guessedCount; i < guessRes; i++) {
                        res.add(cand);
                    }
                    iter.remove();
                } else {
                    // something wrong here
                    return genNumber(res);
                }
            }
            if (res.size() < 4) {
                for (int i = res.size(); i < 4; i++)
                    res.add(6);
            }

            // System.out.println("guessed " + counter + " times");
            return genNumber(res);
        }
    }

    public static class UnitTest {
        @Test
        public void test() {
            String guess = "2345";
            Solution sol = new GuessNumber().new Solution(guess);
            assertEquals(guess, sol.guess());

            guess = "3456";
            sol = new GuessNumber().new Solution(guess);
            assertEquals(guess, sol.guess());

            guess = "4536";
            sol = new GuessNumber().new Solution(guess);
            char[] res = guess.toCharArray();
            Arrays.sort(res);
            assertEquals(new String(res), sol.guess());

            guess = "1111";
            sol = new GuessNumber().new Solution(guess);
            assertEquals(guess, sol.guess());

            guess = "6666";
            sol = new GuessNumber().new Solution(guess);
            assertEquals(guess, sol.guess());

            guess = "2266";
            sol = new GuessNumber().new Solution(guess);
            assertEquals(guess, sol.guess());

            guess = "5566";
            sol = new GuessNumber().new Solution(guess);
            assertEquals(guess, sol.guess());
        }
    }
}


Requirements
Java >= 1.8.151
Gradle >= 4.2.1
Run Unit Tests
If you write some unit tests, you can use the following command to run them.

# run all tests
gradle test 
# run Palindrome Pairs test only
gradle -Dtest.single=PalindromePairs test
# run Palindrome Pairs test only with some informnation
gradle -Dtest.single=PalindromePairs test --info
